using System;
using Logictracker.MaxTrack;
using Logictracker.Utils;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Logictracker.Testing.Codecs
{
    /// <summary>
    /// Summary description for MaxTrack
    /// </summary>
    [TestClass]
    public class MaxTrack
    {
        /// <summary>
	    ///Gets or sets the test context which provides
	    ///information about and functionality for the current test run.
	    ///</summary>
	    public TestContext TestContext { get; set; }

	    [TestMethod]
        public void Crc16CcittStatico()
        {
            ushort crc = 0; 
            crc = Parser.Crc16Ccitt(crc,0xa3); // Device Type 
            crc = Parser.Crc16Ccitt(crc, 0x02); // ACK Type Packet             
            crc = Parser.Crc16Ccitt(crc, 0x05); // ID 
            crc = Parser.Crc16Ccitt(crc, 0x00); // ID 
            crc = Parser.Crc16Ccitt(crc, 0x50); // ID 
            crc = Parser.Crc16Ccitt(crc, 0x00); // ID 
            crc = Parser.Crc16Ccitt(crc, 0x53); // Param Byte (Position ACK) 
            crc = Parser.Crc16Ccitt(crc, 0x8d); // Param Byte (Position ACK)

            //
            if (crc != 0x038c) throw new ApplicationException();
        }

        [TestMethod]
        public void Crc16CcittBuffer()
        {
            byte[] buffer = { 0x01,0xa3 ,0x31 ,0x05 ,0x00 ,0x50 ,0x00 ,0x08 ,0x06 ,0xcb ,0x45 ,0x89 ,0xf9 ,0x18 ,0x1c ,0xf6 
                                ,0xd2 ,0xcf ,0xFe ,0x84 ,0x62 ,0x61 ,0xfd ,0x80 ,0x23 ,0x28 ,0x80 ,0x02 ,0x00 ,0x05 ,0x03 ,0x2e ,0x06 ,0x02 
                                ,0x00 ,0x49 ,0x1b ,0xf4 ,0x27 ,0x50 ,0x00 ,0x83 ,0x00 ,0x7e ,0x50 ,0x53 ,0x8d ,0x04 };
            
            ushort crc = Parser.Crc16Ccitt(buffer);

            if (crc != 0x8d53) throw new ApplicationException();
        }

        [TestMethod]
        public void MakeAcknowledge()
        {
            byte[] buffer = { 0x01,0xa3 ,0x31 ,0x05 ,0x00 ,0x50 ,0x00 ,0x08 ,0x06 ,0xcb ,0x45 ,0x89 ,0xf9 ,0x18 ,0x1c ,0xf6 
                                ,0xd2 ,0xcf ,0xFe ,0x84 ,0x62 ,0x61 ,0xfd ,0x80 ,0x23 ,0x28 ,0x80 ,0x02 ,0x00 ,0x05 ,0x03 ,0x2e ,0x06 ,0x02 
                                ,0x00 ,0x49 ,0x1b ,0xf4 ,0x27 ,0x50 ,0x00 ,0x83 ,0x00 ,0x7e ,0x50 ,0x53 ,0x8d ,0x04 };

            var replay = Parser.MakeAck(buffer);
            byte[] expected = { 0x01, 0xa3, 0x02, 0x05, 0x00, 0x50, 0x00, 0x53, 0x8d, 0x8c, 0x03, 0x04 };
            for (int i = 0; i < 12; ++i)
            {
                if (replay[i] != expected[i]) throw new ApplicationException();
            }                       
        }

        [TestMethod]
        public void DecodePosition()
        {
            /*
             byte[] buffer = { 0x01,0xa3 ,0x31 ,0x05 ,0x00 ,0x50 ,0x00 ,0x08 ,0x06 ,0xcb ,0x45 ,0x89 ,0xf9 ,0x18 ,0x1c ,0xf6 
                                ,0xd2 ,0xcf ,0xFe ,0x84 ,0x62 ,0x61 ,0xfd ,0x80 ,0x23 ,0x28 ,0x80 ,0x02 ,0x00 ,0x05 ,0x03 ,0x2e ,0x06 ,0x02 
                                ,0x00 ,0x49 ,0x1b ,0xf4 ,0x27 ,0x50 ,0x00 ,0x83 ,0x00 ,0x7e ,0x50 ,0x53 ,0x8d ,0x04 };
             * 
             * 
             * 
             byte[] buffer = { 0x1, 0xA2, 0x31, 0xC0, 0x2D, 0x40, 0x0, 0x8, 
                    0x0, 0x76, 0x10, 0x21, 0x4D, 0xF6, 0xD4, 0x22, 
                    0x5C, 0x8C, 0xCF, 0xFE, 0xB2, 0x55, 0x5E, 0xFD, 
                    0x0, 0x28, 0x0, 0xC0, 0x10, 0x21, 0x0, 0xF2, 
                    0x27, 0xF0, 0x10, 0x33, 0xBC, 0x1B, 0x62, 0x75, 
                    0x40, 0x26, 0x4,  };
            */

            byte[] buffer = { 0x1, 0xA2, 0x31, 0xC0, 0x2D, 0x40, 0x0, 0x8, 
                                0x0, 0x73, 0x10, 0x21, 0xF8, 0x10, 0x30, 0xDB, 
                                0x22, 0x5C, 0x8C, 0xCF, 0xFE, 0xB2, 0x55, 0x5E, 
                                0xFD, 0x0, 0x28, 0x0, 0xC0, 0x10, 0x21, 0x0, 
                                0xF2, 0x27, 0xF0, 0x10, 0x33, 0xBC, 0x1B, 0x62, 
                                0x75, 0x16, 0xB8, 0x4 };
            
            var stuff = Parser.ByteStuffing(buffer);
            Parser.PrintBufferAsCode(stuff);
            //var replay = 
		    Parser.GetPosition(stuff);
        }

        [TestMethod]
        public void Testdatetimeparser()
        {
	        var expected = new DateTime(2013, DateTime.UtcNow.Month, 27, 18, 16, 16);
	        var actual = DateTimeUtils.SafeParseFormat("071213181616", "ddMMyyHHmmss");
			Assert.AreEqual(expected, actual);
        }
    }
}

